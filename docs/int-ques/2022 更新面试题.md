---
sidebar_position: 1
---

## 什么是异步函数？

js 是单线程语言，只能同时处理一个任务，如果请求的是后端，这个响应可能是几秒之后才响应，所以要先跳过这个任务，继续向下执行。必须等主进程全部执行完成之后再执行异步函数。就算主进程再慢，也要等主进程全部加载完成之后再加载。

## 微任务和宏任务是什么？

因为 js 是单线程语言，它就好比是一个人在工作，但是同一时间只能做一项工作，所以就产生了任务队列，需要将接下来的工作都放到任务队列里面编排，干完一项任务之后再进行下一项任务。

但是任务队列还会分成三种：`主任务队列、微任务队列、宏任务队列`，每种不同的任务类型会放在不同的任务队列中，同步代码从上到下，都会放在 `主任务队列`中；异步函数，如：`setTimeout`、`setInterval`，属于异步函数，会放在 `宏任务队列`；那么`微任务`呢，指的就是 **Promise 通过 .then() 的回调**。

任务也是存在优先级的，他们之间的优先级为：`主任务队列 > 微任务队列 > 宏任务队列`

例如下面代码演示：

```js
setTimeout(() => {
  console.log('setTimeout') // 宏任务
}, 0)

new Promise((resolve) => {
  console.log('Promise') // 这里也是主进程
  resolve('成功了')
}).then((res) => {
  console.log(res) // 微任务
})

console.log('主进程') // 主进程

// 日志：
// Promise
// 主进程
// 成功了
// setTimeout
```

## node 有什么优势？

node 是一个 javascript 的运行环境，使用这个环境去搭建上层的一些应用。可以使用它打、运行，或者当作服务器去运行一些工具，开发环境，这是 node 的主要作用。

node 处理[高并发](https://blog.csdn.net/weixin_42476601/article/details/82220027)是有天然优势的，它的机制就是：单线程、事件循环，事件驱动这个机制可以处理高并发请求，但是 node 主要是做服务器渲染。

## new 操作符都做了什么？

- 在内存中新建一个对象
- 这个新对象内部的 `[[prototype]]` 特性被赋值为函数的 `prototype` 属性
- 构造函数内部的 `this` 被赋值为这个新对象（即 `this` 指向新对象）
- 指向构造函数内部的代码（给新对象添加属性）
- 如果构造函数没有返回其它对象，那么就返回刚创建的新对象

## 怎么做性能优化？

## 如何中断已发出去的请求？

## window.localStorage 怎么设置过期时间？

## 反转二叉树是什么？

## 最长递增子序列是什么？

## 动态规划是什么？

## 设计模式是什么？

## 用户从输入 URL，然后点击回车，到页面完全显示出来，这一过程中到底发生了什么？
